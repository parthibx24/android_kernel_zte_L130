/*
 * File: Altek_ahb_drv.c                                                     *
 * Description: ISP AHB Ctrl driver                                          *
 *                                                                           *
 * (C)Copyright altek Corporation 2014                                       *
 *                                                                           *
 * History:                                                                  *
 *   2014/07/17; Bruce Chung; Initial version                                *
 */

/*
 * //////////////////////////////////////////////
 *                      Include File                          *
 * /////////////////////////////////////////////
 */
#include "altek_os_info.h"
#include <linux/module.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/moduleparam.h>
#include <linux/delay.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#include "altek_ahb_drv.h"
#include "altek_ahb_reg.h"
#include "altek_cmd.h"
#include "altek_dump_utility.h"
#include "altek_log_local.h"
#include "altek_common.h"

/*
 * ////////////////////////////////////////////////
 *                 Private Constant Definition                 *
 * ////////////////////////////////////////////////
 */

/* #define ALTEK_ISP_AHB_BASE_ADDR             0xD9020000 */
/* #define ALTEK_ISP_AHB_ADDR_Length           0x00010000 */

#define AHB_ENTRY_OFFSET		0xBC
#define BOOT_CODE_SIZE			64

/* TO DO ---- Set the clock */
#ifdef _ISP_LINUXOS_ENV_
#define ICLK1       300000000
#define ICLK2       200000000
#define MCLK        384000000
#define PCLK          76800000
#define CAMx_MCLK    24000000
#elif defined _ISP_NONOS_ENV_
#define ICLK1       300000000
#define ICLK2       200000000
#define MCLK         26000000
#define PCLK         26000000
#define CAMx_MCLK    24000000
#endif
/* End of TO DO */

static char *cmd; /* command buffer of the isp_dev interface */
static char *response; /* command response buffer of the isp_dev interface */
static u32 sizeof_response;
static u32 lenof_response; /* length of content */

static struct ispahb_field_info g_at_ahb_reg_field_info[AHB_ITEM_MAX] = {
	{AHB_ENTRY_SYS_CONTROL,  0, 0x00000001},
	{AHB_ENTRY_SYS_INFO,  0, 0x0000FFFF},
	{AHB_ENTRY_SYS_INFO, 16, 0xFFFF0000},
	{AHB_ENTRY_SYS_STATUS,	0, 0x00000001},
	{AHB_ENTRY_SYS_STATUS,	1, 0x00000002},
	{AHB_ENTRY_SYS_STATUS,	2, 0x00000004},
	{AHB_ENTRY_SYS_STATUS,	3, 0x00000008},
	{AHB_ENTRY_SYS_MESSAGE,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX,  0, 0x00000003},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX,  2, 0x0000000C},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX,  4, 0x00000030},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX,  6, 0x000000C0},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX,  8, 0x00000300},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 10, 0x00000C00},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 12, 0x00003000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 14, 0x0000C000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 16, 0x00030000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 18, 0x000C0000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 20, 0x00300000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 22, 0x00C00000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 24, 0x03000000},
	{AHB_ENTRY_SYS_SENSOR_OUT_INDEX, 26, 0x0C000000},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO,  0, 0x00000003},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO,  2, 0x0000000C},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO,  4, 0x00000070},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO,  7, 0x00000180},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO,  9, 0x00000600},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 11, 0x00001800},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 13, 0x0000E000},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 16, 0x00030000},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 18, 0x000C0000},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 20, 0x00700000},
	{AHB_ENTRY_SYS_CHANGE_OUT_SETTING_INFO, 23, 0x01800000},
	{AHB_ENTRY_SYS_LOG_BUF_WRITE_PTR,  0, 0x0000FFFF},
	{AHB_ENTRY_SYS_LOG_BUF_SIZE,  0, 0x0000FFFF},
	{AHB_ENTRY_SYS_LOG_BUF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SYS_WORK_BUF_SIZE,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SYS_WORK_BUF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SYS_EXT_BUF_INFO,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SYS_GSENSOR_VECTOR_1,  0, 0x0000FFFF},
	{AHB_ENTRY_SYS_GSENSOR_VECTOR_1, 16, 0xFFFF0000},
	{AHB_ENTRY_SYS_GSENSOR_VECTOR_2,  0, 0x0000FFFF},
	{AHB_ENTRY_SYS_CMD_TOKEN_ADDR,	0, 0xFFFFFFFF},
	{AHB_ENTRY_COMMAND_SYSTEM,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SYSTEM,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SYSTEM,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SYSTEM,  3, 0x00000008},
	{AHB_ENTRY_COMMAND_SYSTEM,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SYSTEM,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SYSTEM,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SYSTEM,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SYSTEM,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SYSTEM,  9, 0x00000200},
	{AHB_ENTRY_COMMAND_SYSTEM, 10, 0x00000400},
	{AHB_ENTRY_COMMAND_SYSTEM, 11, 0x00000800},
	{AHB_ENTRY_COMMAND_SYSTEM, 12, 0x00001000},
	{AHB_ENTRY_COMMAND_SYSTEM, 13, 0x00002000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1,  9, 0x00000200},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 10, 0x00000400},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 11, 0x00000800},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 12, 0x00001000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 13, 0x00002000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 14, 0x00004000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 15, 0x00008000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 16, 0x00010000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 17, 0x00020000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 18, 0x00040000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 19, 0x00080000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 20, 0x00100000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 21, 0x00200000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 22, 0x00400000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 23, 0x00800000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 24, 0x01000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 25, 0x02000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 26, 0x04000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 27, 0x08000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 28, 0x10000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 29, 0x20000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 30, 0x40000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP1, 31, 0x80000000},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  3, 0x00000008},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_1_GROUP2,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1,  9, 0x00000200},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 10, 0x00000400},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 11, 0x00000800},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 12, 0x00001000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 13, 0x00002000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 14, 0x00004000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 15, 0x00008000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 16, 0x00010000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 17, 0x00020000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 18, 0x00040000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 19, 0x00080000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 20, 0x00100000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 21, 0x00200000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 22, 0x00400000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 23, 0x00800000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 24, 0x01000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 25, 0x02000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 26, 0x04000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 27, 0x08000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 28, 0x10000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 29, 0x20000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 30, 0x40000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP1, 31, 0x80000000},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  3, 0x00000008},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_2_GROUP2,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  0, 0x00000001},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  8, 0x00000100},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1,  9, 0x00000200},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 10, 0x00000400},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 11, 0x00000800},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 12, 0x00001000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 13, 0x00002000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 14, 0x00004000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 15, 0x00008000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 16, 0x00010000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 17, 0x00020000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 18, 0x00040000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 19, 0x00080000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 20, 0x00100000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 21, 0x00200000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 22, 0x00400000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 23, 0x00800000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 24, 0x01000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 25, 0x02000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 26, 0x04000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 27, 0x08000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 28, 0x10000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 29, 0x20000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 30, 0x40000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP1, 31, 0x80000000},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  1, 0x00000002},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  2, 0x00000004},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  3, 0x00000008},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  4, 0x00000010},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  5, 0x00000020},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  6, 0x00000040},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  7, 0x00000080},
	{AHB_ENTRY_COMMAND_SENSOR_3_GROUP2,  8, 0x00000100},
	{AHB_ENTRY_INT_SYS_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_INT_SYS_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_INT_SYS_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_INT_SYS_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SYS_STATUS,  1, 0x00000002},
	{AHB_ENTRY_INT_SYS_STATUS,  2, 0x00000004},
	{AHB_ENTRY_SENSOR_1_CONFIG_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_YUY2_USER_DEF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_TONEMAP_DATA_ADDR,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_MOTION_DATA_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG_TYPE,  0, 0x00000003},
	{AHB_ENTRY_SENSOR_1_OUT_IMG_TYPE,  2, 0x0000000C},
	{AHB_ENTRY_SENSOR_1_OUT_IMG_TYPE,  4, 0x00000030},
	{AHB_ENTRY_SENSOR_1_OUT_IMG_TYPE,  6, 0x000001C0},
	{AHB_ENTRY_SENSOR_1_OUT_IMG_TYPE,  9, 0x00000600},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_1_OUT_LINE_OFFSET_1,	0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_OUT_LINE_OFFSET_1, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_1_OUT_LINE_OFFSET_2,	0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_OUT_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_SENSOR_1_OUT_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_SENSOR_1_OUT_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_SENSOR_1_OUT_ENABLE,  3, 0x00000008},
	{AHB_ENTRY_SENSOR_1_OUT_BUF_NUM,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_1_OUT_BUF_NUM,  8, 0x0000FF00},
	{AHB_ENTRY_SENSOR_1_OUT_BUF_NUM, 16, 0x00FF0000},
	{AHB_ENTRY_SENSOR_1_OUT_BUF_NUM, 24, 0xFF000000},
	{AHB_ENTRY_SENSOR_1_OUT_BUF_NUM_2,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_STATICS_ADDR1,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_STATICS_ADDR2,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_STATICS_ADDR3,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_STATICS_ADDR4,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_AF_STATICS_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_AF_STATICS_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_AF_STATICS_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_AF_STATICS_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_RAW_ADD1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_RAW_ADD2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_RAW_ADD3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_RAW_ADD4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR1_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR2_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR3_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR4_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR1_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR2_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR3_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR4_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR1_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR2_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR3_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR4_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR1_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR2_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR3_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG1_ADDR4_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR1_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR2_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR3_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG2_ADDR4_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR1_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR2_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR3_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_OUT_IMG3_ADDR4_NV12_UV_ISP1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1,  0, 0x0000000F},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1,  4, 0x000000F0},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1,  8, 0x00000F00},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 12, 0x0000F000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 16, 0x00010000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 17, 0x00060000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 19, 0x00080000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 20, 0x00100000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 21, 0x00E00000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 24, 0x07000000},
	{AHB_ENTRY_SENSOR_1_QUALITY_SETTING1, 27, 0x18000000},
	{AHB_ENTRY_SENSOR_1_DLD3ASEQ_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_CFG3A_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_DZOOMINFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_QMERGE_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_SHADING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_CBC_MAP_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING1,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING1, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING2,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING2, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING3,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING4,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING4, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING5,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_1_DETECT_SETTING5, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_1_DEBUG_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_CCM_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_IQ_OTP_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_VALID_EXPOSURE_TIME,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_VALID_AD_GAIN,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_COLOR_TEMPERATURE,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_BRIGHTNESS_SETTING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_RAW_SETTING,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_1_RAW_SETTING,  8, 0x00000F00},
	{AHB_ENTRY_SENSOR_1_RAW_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_PROC_STILL_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_AD_SHAD_BUF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_IQ_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_ISP_D_GAIN_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_Y_OFFSET,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_1_IQ_PARAM_INDEX_SETTING,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_1_IQ_PARAM_INDEX_SETTING,  8, 0x0000FF00},
	{AHB_ENTRY_SENSOR_1_IQ_PARAM_INDEX_SETTING, 16, 0x00FF0000},
	{AHB_ENTRY_SENSOR_2_YUY2_USER_DEF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_TONEMAP_DATA_ADDR,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_MOTION_DATA_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG_TYPE,  0, 0x00000003},
	{AHB_ENTRY_SENSOR_2_OUT_IMG_TYPE,  2, 0x0000000C},
	{AHB_ENTRY_SENSOR_2_OUT_IMG_TYPE,  4, 0x00000030},
	{AHB_ENTRY_SENSOR_2_OUT_IMG_TYPE,  6, 0x000001C0},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_2_OUT_LINE_OFFSET_1,	0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_OUT_LINE_OFFSET_1, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_2_OUT_LINE_OFFSET_2,	0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_OUT_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_SENSOR_2_OUT_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_SENSOR_2_OUT_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_SENSOR_2_OUT_ENABLE,  3, 0x00000008},
	{AHB_ENTRY_SENSOR_2_OUT_BUF_NUM,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_2_OUT_BUF_NUM,  8, 0x0000FF00},
	{AHB_ENTRY_SENSOR_2_OUT_BUF_NUM, 16, 0x00FF0000},
	{AHB_ENTRY_SENSOR_2_OUT_BUF_NUM, 24, 0xFF000000},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_STATICS_ADDR1,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_STATICS_ADDR2,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_STATICS_ADDR3,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_STATICS_ADDR4,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_AF_STATICS_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_AF_STATICS_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_AF_STATICS_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_AF_STATICS_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG1_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG2_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_OUT_IMG3_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1,  0, 0x0000000F},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1,  4, 0x000000F0},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1,  8, 0x00000F00},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 12, 0x0000F000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 16, 0x00010000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 17, 0x00060000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 19, 0x00080000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 20, 0x00100000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 21, 0x00E00000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 24, 0x07000000},
	{AHB_ENTRY_SENSOR_2_QUALITY_SETTING1, 27, 0x18000000},
	{AHB_ENTRY_SENSOR_2_DLD3ASEQ_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_CFG3A_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_DZOOMINFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_QMERGE_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_SHADING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_CBC_MAP_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING1,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING1, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING2,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING2, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING3,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING4,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING4, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING5,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_2_DETECT_SETTING5, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_2_DEBUG_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_CCM_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_IQ_OTP_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_VALID_EXPOSURE_TIME,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_VALID_AD_GAIN,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_COLOR_TEMPERATURE,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_BRIGHTNESS_SETTING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_RAW_SETTING,  0, 0x0000000F},
	{AHB_ENTRY_SENSOR_2_AD_SHAD_BUF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_IQ_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_ISP_D_GAIN_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_Y_OFFSET,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_2_IQ_PARAM_INDEX_SETTING,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_2_IQ_PARAM_INDEX_SETTING,  8, 0x0000FF00},
	{AHB_ENTRY_SENSOR_2_IQ_PARAM_INDEX_SETTING, 16, 0x00FF0000},
	{AHB_ENTRY_SENSOR_3_YUY2_USER_DEF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_TONEMAP_DATA_ADDR,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_MOTION_DATA_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG_TYPE,  0, 0x00000003},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_RESOLUTION,  0, 0x00001FFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_RESOLUTION, 16, 0x1FFF0000},
	{AHB_ENTRY_SENSOR_3_OUT_LINE_OFFSET,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_OUT_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_SENSOR_3_OUT_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_SENSOR_3_OUT_BUF_NUM,  0, 0x000000FF},
	{AHB_ENTRY_SENSOR_3_OUT_BUF_NUM,  8, 0x0000FF00},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_STATICS_ADDR1,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_STATICS_ADDR2,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_STATICS_ADDR3,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_STATICS_ADDR4,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_AF_STATICS_ADDR1,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_AF_STATICS_ADDR2,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_AF_STATICS_ADDR3,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_AF_STATICS_ADDR4,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR1_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR2_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR3_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_OUT_IMG1_ADDR4_NV12_UV,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1,  4, 0x000000F0},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1,  8, 0x00000F00},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 12, 0x0000F000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 16, 0x000F0000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1,  9, 0x00000200},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 10, 0x00000C00},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 15, 0x00008000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 20, 0x00100000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 21, 0x00E00000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 24, 0x07000000},
	{AHB_ENTRY_SENSOR_3_QUALITY_SETTING1, 27, 0x18000000},
	{AHB_ENTRY_SENSOR_3_DLD3ASEQ_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_CFG3A_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_DZOOMINFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_QMERGE_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_SHADING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_CBC_MAP_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING1,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING1, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING2,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING2, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING3,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING4,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING4, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING5,  0, 0x0000FFFF},
	{AHB_ENTRY_SENSOR_3_DETECT_SETTING5, 16, 0xFFFF0000},
	{AHB_ENTRY_SENSOR_3_DEBUG_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_CCM_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_IQ_OTP_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_VALID_EXPOSURE_TIME,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_VALID_AD_GAIN,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_COLOR_TEMPERATURE,	0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_BRIGHTNESS_SETTING_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_RAW_SETTING,  0, 0x0000000F},
	{AHB_ENTRY_SENSOR_3_AD_SHAD_BUF_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_IQ_INFO_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_ISP_D_GAIN_ADDR,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_Y_OFFSET,  0, 0xFFFFFFFF},
	{AHB_ENTRY_SENSOR_3_IQ_PARAM_INDEX_SETTING,  0, 0x000000FF},
	{AHB_ENTRY_OVERLAP_PIXEL_NUM,  0, 0x0000FFFF},
	{AHB_ENTRY_ISP_CHIP_ID,  0, 0x0000FFFF},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  3, 0x00000008},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  4, 0x00000010},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  5, 0x00000020},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  6, 0x00000040},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  7, 0x00000080},
	{AHB_ENTRY_INT_SENSOR_1_ENABLE,  8, 0x00000100},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  3, 0x00000008},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  4, 0x00000010},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  5, 0x00000020},
	{AHB_ENTRY_INT_SENSOR_2_ENABLE,  6, 0x00000040},
	{AHB_ENTRY_INT_SENSOR_3_ENABLE,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_ENABLE,  1, 0x00000002},
	{AHB_ENTRY_INT_SENSOR_3_ENABLE,  2, 0x00000004},
	{AHB_ENTRY_INT_SENSOR_3_ENABLE,  3, 0x00000008},
	{AHB_ENTRY_INT_SENSOR_3_ENABLE,  4, 0x00000010},
	{AHB_ENTRY_INT_SENSOR_1_IMG1_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_IMG2_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_IMG3_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_3A_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_AF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_ISP_SOF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_3A_LINEMEET_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_STILL_PROC_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_1_RAW_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_IMG1_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_IMG2_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_IMG3_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_3A_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_AF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_ISP_SOF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_2_3A_LINEMEET_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_IMG_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_3A_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_AF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_ISP_SOF_STATUS,  0, 0x00000001},
	{AHB_ENTRY_INT_SENSOR_3_3A_LINEMEET_STATUS,  0, 0x00000001}
};

/*
 * /////////////////////////////////////////////////////
 *              Private Function Prototype                    *
 * ////////////////////////////////////////////////////
 */
static u32 get_reg_offset(u16 entry_id);
static u8 get_shift_bit_num(u32 mask);
static ssize_t show_isp(struct device *dev_t,
			struct device_attribute *attr, char *buf);
static ssize_t store_isp(struct device *dev_t,
			 struct device_attribute *attr, const char *buf,
			 size_t count);

/*
 * ////////////////////////////////////////////////////
 *                      Global Variable                       *
 * ////////////////////////////////////////////////////
 */

static int ispfps = 30;
module_param(ispfps, int, 0664);

static int isplog = 1; /* FIXME: remove it, since it's always on */
module_param(isplog, int, 0664);

static int ahblog = NUMBER_ZERO;
module_param(ahblog, int, 0664);

static int metalog = NUMBER_ZERO;
module_param(metalog, int, 0664);

static DEVICE_ATTR(isp, S_IWUSR | S_IRUGO, show_isp, store_isp);
static u8 *base_addr;
static u32 ahb_size;
static dev_t dev;
static struct device *device;
static struct cdev c_dev;
static struct class *cl;

static ssize_t isp_dev_read(struct file *f, char __user *buf,
			    size_t len, loff_t *off)
{
	static char *pt;
	static u32 left, cpy_cnt;
	char *tmp; /* to make checkpatch.pl shut up */

	/* TODO: reentrant protection */

	if (!response || !sizeof_response ||
	    !lenof_response || *response == '\0') {
		return 0;
	}

	if (!pt)
		pt = response;
	if (!left)
		left = lenof_response;

	if (left > PAGE_SIZE)
		cpy_cnt = PAGE_SIZE;
	else
		cpy_cnt = left;

	if (copy_to_user(buf, pt, cpy_cnt))
		return -EFAULT;

	pt += cpy_cnt;
	left -= cpy_cnt;

	if (!left) {
		pt = NULL;
		lenof_response = 0;
		sizeof_response = PAGE_SIZE;
		tmp = krealloc(response, sizeof_response,
				    GFP_KERNEL); /* shrink */
		/* TODO: shrink fail? */
		response = tmp; /* to make checkpatch.pl shut up */
		*response = '\0';
	}

	return cpy_cnt;
}

static ssize_t isp_dev_write(struct file *f, const char __user *buf,
			     size_t len, loff_t *off)
{
	ssize_t bytes_written = 0;

	/* TODO: reentrant protection */

	if (!cmd)
		cmd = kmalloc(PAGE_SIZE, GFP_KERNEL);

	if (copy_from_user(cmd, buf, PAGE_SIZE)) {
		bytes_written = -EFAULT;
		goto end_of_isp_dev_write;
	}

	isp_cmd(cmd);
	bytes_written = PAGE_SIZE;

end_of_isp_dev_write:
	return bytes_written;
}

static const struct file_operations isp_fops = {
	.owner = THIS_MODULE,
	.open = NULL,
	.read = isp_dev_read,
	.write = isp_dev_write,
};

/*
 * ///////////////////////////////////////////////////////
 *                    Public Function                         *
 * ///////////////////////////////////////////////////////
 */
/*	init ahb and bootcode */
u32 isp_open(u64 ahb_base_addr, u32 _ahb_size, u32 *bootcode)
{
	u32 err = 0;
	/* u32 boot, boot_ahb_reg, i; */

	isp_debug_lo_start_tag();

	/* 1. remap the ahb base addr */
	base_addr = (u8 *) ahb_base_addr;
	ahb_size = _ahb_size;

	if (!base_addr) {
		isp_err_lo_combo_desc_tag("ioremap failed");
		err = ENOMEM;
		return err;
	}
	isp_debug_item_tag("base_addr 0x%llx", (u64)base_addr);

	/* 2. load the boot code */
	isp_set_reg_value(0x0, 0x00002069);
	isp_set_reg_value(0x4, 0x0f802020);
	isp_set_reg_value(0x8, 0x02000004);

	/* mclk & pclk */
	isp_set_reg_value(0x38, MCLK);
	isp_set_reg_value(0x3c, PCLK);

	isp_debug_desc_tag("success");
	isp_debug_lo_end_tag();

	return err;
}
EXPORT_SYMBOL(isp_open);

u32 isp_close(void)
{
	u32 err = 0;

	/* unmap ahb */
	if (base_addr)
		UNMAP_IVA_TO_KVA(base_addr);

	return err;
}
EXPORT_SYMBOL(isp_close);

/* ISP internal address is 32 bit */
void set_ahb_indirect(u32 addr, u32 wdata)
{
	u32 cmd_phase = 0;

	isp_debug_lo_start_tag();

	cmd_phase = ((addr >> 2) << 2) + 2;
	isp_set_reg_value(0x58, cmd_phase);
	isp_set_reg_value(0x5c, wdata);

	while ((isp_get_reg_value(0x58) & 0x1) != 0x1)
		isp_debug_desc_tag("Wait AHB register access done\n");

	isp_debug_item_tag("AHB WrReg addr = 0x%x, data = 0x%x done\n",
		addr, wdata);
	isp_debug_lo_end_tag();
}
EXPORT_SYMBOL(set_ahb_indirect);

u32 get_ahb_indirect(u32 addr)
{
	u32 cmd_phase = 0;
	u32 REG;

	isp_debug_lo_start_tag();

	cmd_phase = ((addr >> 2) << 2) + 0;
	isp_set_reg_value(0x58, cmd_phase);
	/*  wait indirect read done */
	while ((isp_get_reg_value(0x58) & 0x1) != 0x1)
		isp_debug_item_tag("Wait Indirect read done, address = 0x%x\n",
			addr);

	REG = isp_get_reg_value(0x5c);
	isp_debug_item_tag("AHB RdReg addr = 0x%x, data = 0x%x done\n",
		addr, REG);

	isp_debug_lo_end_tag();

	return REG;
}
EXPORT_SYMBOL(get_ahb_indirect);

/*
 * \brief get the sw defined register by field name
 * \param field_id [in], field name
 * \return The value in the specific field
 */
u32 isp_get_field_value(u32 field_id)
{
	u16 entry_id;
	u32 entry_value, field_value, entry_mask;

	entry_id = g_at_ahb_reg_field_info[field_id].entry_id;
	entry_mask = g_at_ahb_reg_field_info[field_id].entry_mask;

	entry_value = isp_get_entry_value(entry_id);
	field_value =
	    (entry_value & entry_mask) >> get_shift_bit_num(entry_mask);

#if 0 /* TODO: */
	if (field_id == AHB_ITEM_SYSTEM_MESSAGE)
		auto_dump_on_error(field_value);
#endif
	return field_value;
}
EXPORT_SYMBOL(isp_get_field_value);

/*
 * \brief set the sw defined register by field name
 * \param field_id [in], field name
 * \param value [in], input value
 * \return The value at the entry address
 */
void isp_set_field_value(u32 field_id, u32 value)
{
	u16 entry_id;
	u32 entry_value, entry_mask;

	entry_id = g_at_ahb_reg_field_info[field_id].entry_id;
	entry_mask = g_at_ahb_reg_field_info[field_id].entry_mask;

	entry_value = isp_get_entry_value(entry_id);
	/* isp_info("read_value: 0x%x\n", entry_value); */

	/* shift the input value to the correct position */
	value = (value << get_shift_bit_num(entry_mask)) & entry_mask;

	/* applied the new value to the entry */
	entry_value = (~entry_mask & entry_value) | value;
	/* isp_info("set_value: 0x%x\n", entry_value); */

	isp_set_entry_value(entry_id, entry_value);

	/* isp_info("%s - field id:%d value:0x%08x",
	 * __func__, field_id, value);
	 */

}
EXPORT_SYMBOL(isp_set_field_value);

int in_altek_isp_ahb_range(unsigned long _addr)
{
	u8 *addr = (u8 *)_addr;

	if (ahb_size == 0)
		return 0;
	if (addr < base_addr)
		return 0;
	if (addr >= base_addr + ahb_size)
		return 0;

	return 1;
}
EXPORT_SYMBOL(in_altek_isp_ahb_range);

u32 isp_get_reg_value(u32 addr_offset)
{
	u32 value;

	if (!base_addr)
		return 0;

	value = IOREAD32((u32 *)(base_addr + addr_offset));

	return value;
}
EXPORT_SYMBOL(isp_get_reg_value);

void isp_set_reg_value(u32 addr_offset, u32 value)
{
	if (!base_addr)
		return;

	IOWRITE32(value, (u32 *)(base_addr + addr_offset));

	if (ahblog == 1) {
		isp_debug_lo_start_tag();
		isp_debug_item_tag("offset:0x%x value:0x%x\n",
		       addr_offset, value);
		isp_debug_lo_end_tag();
	}
}
EXPORT_SYMBOL(isp_set_reg_value);

/* used only for hw reg field */
void isp_set_hw_field_value(u32 entry, u32 mask, u32 value)
{
	u32 entry_value;

	entry_value = isp_get_reg_value(entry);

	/* shift the input value to the correct position */
	value = (value << get_shift_bit_num(mask)) & mask;

	/* applied the new value to the entry */
	entry_value = (~mask & entry_value) | value;
	isp_set_reg_value(entry, entry_value);

/*	isp_info("%s - value: 0x%08x", __func__, value); */
}
EXPORT_SYMBOL(isp_set_hw_field_value);

/*
 * \brief get entry value by entry id
 * \param entry_id The register entry name
 * \return The value at the entry address
 */
u32 isp_get_entry_value(u16 entry_id)
{
	u32 offset;

	/* get the specified entry address */
	offset = get_reg_offset(entry_id);

	/* get the register value at the address */
	return isp_get_reg_value(offset);
}
EXPORT_SYMBOL(isp_get_entry_value);

/*
 * \brief set entry value by entry id
 * \param entry_index The register entry name
 * \return : None
 */
void isp_set_entry_value(u16 entry_id, u32 value)
{
	u32 offset;

	/* get the specified entry address */
	offset = get_reg_offset(entry_id);

	/* set the register value at the address */
	isp_set_reg_value(offset, value);
}
EXPORT_SYMBOL(isp_set_entry_value);


int get_isplog_flag(void)
{
	return isplog;
}
EXPORT_SYMBOL(get_isplog_flag);

void set_isplog_flag(int flag)
{
	isplog = flag;
}
EXPORT_SYMBOL(set_isplog_flag);

int isp_dev_append_response_raw(const char *fmt, ...)
{
	va_list ap;
	int len = 0;
	char *tmp; /* to make checkpatch.pl shut up */

	/* TODO: reentrant protection */

	if ((sizeof_response - lenof_response) < (PAGE_SIZE/2)) {
		sizeof_response += PAGE_SIZE;
		tmp = krealloc(response, sizeof_response,
				    GFP_KERNEL); /* expand */
		if (!tmp)
			return 0;
		response = tmp; /* to make checkpatch.pl shut up */
	}

	va_start(ap, fmt);
	len += vsnprintf(response + lenof_response + len,
			sizeof_response - lenof_response - len, fmt, ap);
	va_end(ap);

	lenof_response += len;

	return len;
}

int isp_dev_append_response(const char *fmt, ...)
{
	va_list ap;
	int len = 0;
	struct timespec ut;
	char *tmp; /* to make checkpatch.pl shut up */

	/* TODO: reentrant protection */

	if ((sizeof_response - lenof_response) < (PAGE_SIZE/2)) {
		sizeof_response += PAGE_SIZE;
		tmp = krealloc(response, sizeof_response,
				    GFP_KERNEL); /* expand */
		if (!tmp)
			return 0;
		response = tmp; /* to make checkpatch.pl shut up */
	}

	get_monotonic_boottime(&ut);
	len += snprintf(response + lenof_response + len,
			sizeof_response - lenof_response - len,
			"[%06lu.%09lu] ", ut.tv_sec, ut.tv_nsec);

	va_start(ap, fmt);
	len += vsnprintf(response + lenof_response + len,
			sizeof_response - lenof_response - len, fmt, ap);
	va_end(ap);

	lenof_response += len;

	return len;
}

/*
 * /////////////////////////////////////////////
 *                  Private Function                          *
 * /////////////////////////////////////////////
 */
static u32 get_reg_offset(u16 entry_id)
{
	u32 offset;

	offset = (entry_id << 2) + AHB_ENTRY_OFFSET;

	return offset;
}

static u8 get_shift_bit_num(u32 mask)
{
	u8 shiftbits = 0;

	for (shiftbits = 0; shiftbits < 32; shiftbits++) {
		if ((mask >> shiftbits) & 0x01)
			break;
	}

	if (shiftbits < 32)
		return shiftbits;
	else
		return 0;
}

static ssize_t show_isp(struct device *dev_t,
			struct device_attribute *attr, char *buf)
{
	int status = 0;

	return status;
}

static ssize_t store_isp(struct device *dev_t,
	struct device_attribute *attr, const char *buf, size_t count)
{
	int ret = 0;

	isp_debug_lo_start_tag();

	if (count > 0)
		ret = sscanf(buf, "%d %d %d %d", &ispfps, &isplog,
		&ahblog, &metalog);
	else
		count = 0;

	isp_debug_item_tag("fps:%d isplog:%d ahblog:%d metadata_log:%d",
		ispfps, isplog, ahblog, metalog);

	isp_debug_lo_end_tag();

	return count;
}

/*
 * ////////////////////////////////////////////////////////
 *                     Driver init                            *
 * ///////////////////////////////////////////////////////
 */
static int __init altek_isp_init(void)
{
	int err = -1;

	isp_debug_lo_start_tag();

	if (alloc_chrdev_region(&dev, 0, 3, "isp_driver") < 0)
		goto init_end;

	cl = class_create(THIS_MODULE, "ispdrv");
	if (cl == NULL)
		goto chrdev_end;

	device = device_create(cl, NULL, dev, NULL, "isp_dev");

	if (device == NULL)
		goto dev_create_end;

	cdev_init(&c_dev, &isp_fops);

	if (cdev_add(&c_dev, dev, 1) == -1)
		goto cdev_end;

	err = device_create_file(device, &dev_attr_isp);
	if (err) {
		isp_err_lo_combo_desc_tag("create dev attr file failed");
		goto attr_end;
	}

	isp_debug_item_tag("%s - success. fps:%d\n", VERSION, ispfps);
	isp_debug_lo_end_tag();

	return err;

attr_end:
	device_remove_file(device, &dev_attr_isp);

cdev_end:
	device_destroy(cl, dev);

dev_create_end:
	class_destroy(cl);

chrdev_end:
	unregister_chrdev_region(dev, 1);

init_end:
	isp_err_lo_combo_desc_tag("failed\n");
	isp_debug_lo_end_tag();

	return err;
}

static void __exit altek_isp_exit(void)
{
	device_remove_file(device, &dev_attr_isp);
	cdev_del(&c_dev);
	device_destroy(cl, dev);
	class_destroy(cl);
	unregister_chrdev_region(dev, 3);
}

module_init(altek_isp_init);
module_exit(altek_isp_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Bruce Chung <BruceChung@altek.com.tw>");
