/*
 * rt5512.h  --  ALC5512 Smart DMIC bridge driver
 *
 * Copyright 2014 Realtek Semiconductor Corp.
 * Author: Oder Chiou <oder_chiou@realtek.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef _RT5512_H_
#define _RT5512_H_

/*
 * 	TrainDataHeader.
 * 	The header packs training data generated by Sensory which are gram.bin
 * 	and net.bin. It provides info for driver to identify the ID of training
 * 	data and for firmware to load the training data.
 */

#define TD_SYNC 0x2379

typedef struct {
	short sync;			// The value should be TD_SYNC. Otherwise, it is
					// not legal.
	short ID;			// ID of the training data which should have a
					// matching in SMicTDInfo.
	long NetStartOffset;		// The offset (bytes) of start address of net.bin
					// from the start address of gram.bin in Smart Mic.
	long NetEndOffset;		// The offset (bytes) of end address of net.bin
					// from the start address of gram.bin in Smart Mic.
} TrainDataHeader;



/*
 * 	SMicFWHeader & SMicFWSubHeader.
 * 	This header packs FW binaries and provide information for driver to
 * 	load firmware to Smart Mic. The FW package is able to pack a variety
 * 	number of binary, ex: IRAM binary, DRAM binary...etc.
 * 	a SMicFWHeader should be followed by a SMicFWSubHeader which provides
 * 	loading information of training data.
 */

typedef struct {
	unsigned int Offset;		// The location of the binary in this file.
	unsigned int Size;		// The size of the binary.
	unsigned int Addr;		// The address of the binary in Smart Mic.
} SMicBinInfo;


typedef struct {
	unsigned int ID;		// ID of the Train Data. This ID allows driver to
					// find the corresponding Train Data by matching
					// this ID with the ID in TrainDataHeader.
	unsigned int Addr;		// The address of the training data in Smart Mic.
} SMicTDInfo;


#define	SMICFW_SYNC			0x23795888

typedef struct {
	unsigned int Sync;		// The value should be SMICFW_SYNC. Otherwise, it
					// is not legal.
	unsigned int Version;		// Version number of the FW.
	unsigned int NumBin;		// Number of binary file.
	SMicBinInfo *BinArray;		// Information of each binary file.
} SMicFWHeader;

typedef struct {
	unsigned int NumTD;		// Number of training data (trigger).
	SMicTDInfo *TDArray;		// Information of each train data.
} SMicFWSubHeader;


/*
 * SMIC_REG_FW_STATUS
 * It is the address for driver to check the state of SmartMic.
 */
#define	SMIC_REG_FW_STATUS_mask		0x00ff
#define SMIC_REG_FW_STATUS_shift	0x0

/*
 * Value definition of SMIC_REG_FW_STATUS.
 */
#define SMIC_ERR_INIT_SUCCESS		0x1
#define SMIC_ERR_TD_OVERSIZE		0x2
#define SMIC_ERR_TRAP			0x3

#define RT5512_FIRMWARE		"/etc/firmware/" 
#define RT5512_CUSTOM_FIRMWARE		"/etc/firmware/" 


#define RT5512_WAIT_FS_READY_SECONDS 5

#define RT5512_FIRMWARE1	"rt5512_dsp_fw1.bin"
#define RT5512_FIRMWARE2	"rt5512_dsp_fw2.bin"

#define RT5512_RESET				0x00
#define RT5512_ANA_CIRCUIT_CTRL_LDO1		0x02
#define RT5512_ANA_CIRCUIT_CTRL_LDO2		0x03
#define RT5512_ANA_CIRCUIT_CTRL_LDO3		0x04
#define RT5512_ANA_CIRCUIT_CTRL_ADC1_1		0x05
#define RT5512_ANA_CIRCUIT_CTRL_ADC1_2		0x06
#define RT5512_ANA_CIRCUIT_CTRL_ADC2_1		0x07
#define RT5512_ANA_CIRCUIT_CTRL_ADC2_2		0x08
#define RT5512_ANA_CIRCUIT_CTRL_ADC2_3		0x09
#define RT5512_ANA_CIRCUIT_CTRL_MICBST		0x0a
#define RT5512_ANA_CIRCUIT_CTRL_ADCFED		0x0b
#define RT5512_ANA_CIRCUIT_CTRL_INPUTBUF	0x0c
#define RT5512_ANA_CIRCUIT_CTRL_VREF		0x0d
#define RT5512_ANA_CIRCUIT_CTRL_MBIAS		0x0e
#define RT5512_AD_DIG_FILTER_CTRL1		0x2a
#define RT5512_AD_DIG_FILTER_CTRL2		0x2b
#define RT5512_DFT_BIST_SCAN			0x2c
#define RT5512_UPFILTER_CTRL1			0x2d
#define RT5512_UPFILTER_CTRL2			0x2e
#define RT5512_GPIO_CTRL1			0x40
#define RT5512_GPIO_CTRL2			0x41
#define RT5512_GPIO_CTRL3			0x42
#define RT5512_GPIO_STATUS			0x43
#define RT5512_DIG_PAD_CTRL1			0x44
#define RT5512_DIG_PAD_CTRL2			0x45
#define RT5512_DMIC_DATA_CTRL			0x46
#define RT5512_TEST_MODE_CTRL1			0x4c
#define RT5512_TEST_MODE_CTRL2			0x4d
#define RT5512_TEST_MODE_CTRL3			0x4e
#define RT5512_VAD_CTRL1			0x50
#define RT5512_VAD_CTRL2			0x51
#define RT5512_VAD_CTRL3			0x52
#define RT5512_VAD_CTRL4			0x53
#define RT5512_VAD_STATUS1			0x54
#define RT5512_VAD_STATUS2			0x55
#define RT5512_BUF_SRAM_CTRL1			0x57
#define RT5512_BUF_SRAM_CTRL2			0x58
#define RT5512_BUF_SRAM_CTRL3			0x59
#define RT5512_BUF_SRAM_CTRL4			0x5a
#define RT5512_BUF_SRAM_CTRL5			0x5b
#define RT5512_BUF_SRAM_CTRL6			0x5c
#define RT5512_BUF_SRAM_CTRL7			0x5d
#define RT5512_AUTO_MODE_CTRL			0x60
#define RT5512_PWR_ANLG1			0x61
#define RT5512_PWR_ANLG2			0x62
#define RT5512_PWR_DIG				0x64
#define RT5512_PWR_DSP				0x65
#define RT5512_PRIV_INDEX			0x6a
#define RT5512_PRIV_DATA			0x6c
#define RT5512_BUF_MODE_CTRL_PLL_CAL1		0x73
#define RT5512_BUF_MODE_CTRL_PLL_CAL2		0x74
#define RT5512_BUF_MODE_CTRL_PLL_CAL3		0x75
#define RT5512_BUF_MODE_CTRL_PLL_CAL4		0x76
#define RT5512_BUF_MODE_CTRL_PLL_CAL5		0x78
#define RT5512_BUF_MODE_CTRL_PLL_CAL6		0x79
#define RT5512_KEY_FHRASE_CTRL_AVD		0x7b
#define RT5512_AUTO_CLK_SEL_STATUS1		0x7c
#define RT5512_AUTO_CLK_SEL_STATUS2		0x7d
#define RT5512_AUTO_CLK_SEL_STATUS3		0x7e
#define RT5512_AUTO_CLK_SEL_STATUS4		0x7f
#define RT5512_PLL_CLOCK_CTRL1			0x80
#define RT5512_PLL_CLOCK_CTRL2			0x81
#define RT5512_PLL_CLOCK_CTRL3			0x82
#define RT5512_PLL_CAL_CTRL1			0x83
#define RT5512_PLL_CAL_CTRL2			0x84
#define RT5512_PLL_CAL_CTRL3			0x85
#define RT5512_PLL_CAL_CTRL4			0x86
#define RT5512_PLL_CAL_CTRL5			0x87
#define RT5512_PLL_CAL_CTRL6			0x88
#define RT5512_PLL_CAL_CTRL7			0x89
#define RT5512_PLL_CAL_CTRL8			0x8a
#define RT5512_PLL_CAL_CTRL9			0x8b
#define RT5512_PLL_CAL_STATUS1			0x8c
#define RT5512_PLL_CAL_STATUS2			0x8d
#define RT5512_PLL_CAL_STATUS3			0x8e
#define RT5512_DSP_CTRL1			0x90
#define RT5512_DSP_CTRL2			0x91
#define RT5512_DSP_CTRL3			0x92
#define RT5512_DSP_CTRL4			0x93
#define RT5512_DSP_CTRL5			0x94
#define RT5512_DSP_CTRL6			0x95
#define RT5512_DSP_CTRL7			0x96
#define RT5512_DSP_CTRL8			0x97
#define RT5512_DSP_CTRL9			0x98
#define RT5512_DSP_CTRL10			0x99
#define RT5512_DSP_CTRL11			0x9a
#define RT5512_DSP_CTRL12			0x9b
#define RT5512_DSP_CTRL13			0x9c
#define RT5512_DSP_CTRL14			0x9d
#define RT5512_DSP_CTRL15			0x9e
#define RT5512_PLL_CLK_EXT_CTRL1		0xc0
#define RT5512_PLL_CLK_EXT_CTRL2		0xc1
#define RT5512_ADC_EXT_CTRL1			0xc2
#define RT5512_DUMMY_RTK1			0xd0
#define RT5512_DUMMY_RTK2			0xd1
#define RT5512_DUMMY_RTK3			0xd2
#define RT5512_DUMMY_RTK4			0xd3
#define RT5512_DUMMY_RTK5			0xd4
#define RT5512_DUMMY_RTK6			0xd5
#define RT5512_DUMMY_RTK7			0xd6
#define RT5512_DUMMY_RTK8			0xd7
#define RT5512_DUMMY_RTK9			0xd8
#define RT5512_DUMMY_RTK10			0xd9
#define RT5512_DUMMY_RTK11			0xda
#define RT5512_DUMMY_RTK12			0xdb
#define RT5512_DUMMY_RTK13			0xdc
#define RT5512_DUMMY_RTK14			0xdd
#define RT5512_DUMMY_RTK15			0xde
#define RT5512_DUMMY_RTK16			0xdf
#define RT5512_DUMMY_CUSTOMER1			0xe0
#define RT5512_DUMMY_CUSTOMER2			0xe1
#define RT5512_DUMMY_CUSTOMER3			0xe2
#define RT5512_DUMMY_CUSTOMER4			0xe3
#define RT5512_DUMMY_CUSTOMER5			0xe4
#define RT5512_DUMMY_CUSTOMER6			0xe5
#define RT5512_DUMMY_CUSTOMER7			0xe6
#define RT5512_DUMMY_CUSTOMER8			0xe7
#define RT5512_DUMMY_CUSTOMER9			0xe8
#define RT5512_DUMMY_CUSTOMER10			0xe9
#define RT5512_DUMMY_CUSTOMER11			0xea
#define RT5512_DUMMY_CUSTOMER12			0xeb
#define RT5512_DUMMY_CUSTOMER13			0xec
#define RT5512_DUMMY_CUSTOMER14			0xed
#define RT5512_DUMMY_CUSTOMER15			0xee
#define RT5512_DUMMY_CUSTOMER16			0xef
#define RT5512_DSP_MEM_CTRL1			0xf0
#define RT5512_DSP_MEM_CTRL2			0xf1
#define RT5512_DSP_MEM_CTRL3			0xf2
#define RT5512_DSP_MEM_CTRL4			0xf3
#define RT5512_DSP_MEM_CTRL5			0xf4
#define RT5512_DSP_MEM_CTRL6			0xf7
#define RT5512_DSP_MEM_CTRL7			0xf8
#define RT5512_DUMMY1				0xfa
#define RT5512_DUMMY2				0xfb
#define RT5512_DUMMY3				0xfc
#define RT5512_VENDOR_ID			0xfd
#define RT5512_VENDOR_ID1			0xfe
#define RT5512_VENDOR_ID2			0xff

enum {
	RT5512_NORMAL,
	RT5512_DSP,
	RT5512_DSP_ONESHOT,
	RT5512_DSP_RELOAD,
	RT5512_USE_AMIC,
	RT5512_USE_DMIC,
	RT5512_DSP_FAST_RELOAD,
	RT5512_DSP_SET_SENSITIVITY,
};

enum {
	SOUND_TRIGGER_NORMAL,
	SOUND_TRIGGER_EVENT_HAPPENED,
	SOUND_TRIGGER_STOPPING_CAPTURING,
	SOUND_TRIGGER_UPDATE_FIRMWARE,
};






struct rt5512_soundtrigger_data {
		struct miscdevice dev;
		struct mutex irq_lock;
		spinlock_t val_lock;
		volatile int sound_trigger_event_state ;
		unsigned int	irq_gpio;
		struct i2c_client *client;
		struct delayed_work reload_work;
		struct work_struct irq_work;
		struct work_struct  work;
		unsigned char *firmware_data;
		unsigned int  firmware_size;
};

void rt5512_dsp_stop(void);
void rt5512_dsp_start(void);
void rt5512_dsp_one_shot(void);
void rt5512_dsp_reload(struct rt5512_soundtrigger_data* rt5512_st);
int rt5512_irq_is_triggered(void);
static void rt5512_dsp_load_fw(struct rt5512_soundtrigger_data *rt5512_st);

#endif /* _RT5512_H_ */
